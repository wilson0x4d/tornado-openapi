# SPDX-FileCopyrightText: Copyright (C) Shaun Wilson
# SPDX-License-Identifier: MIT

import enum
from typing import Any
from .DescriptionObject import DescriptionObject
from .ParameterLocation import ParameterLocation
from .OAuthFlows import OAuthFlows


class SecuritySchemeType(enum.StrEnum):
    APIKEY = 'apiKey'
    HTTP = 'http'
    MUTUALTLS = 'mutualTLS'
    OAUTH2 = 'oauth2'
    OPENIDCONNECT = 'openIdConnect'


class SecurityScheme(DescriptionObject):
    """
    Defines a security scheme that can be used by the operations.

    Supported schemes are:
    * HTTP authentication
    * an API key (either as a header, a cookie parameter or as a query parameter)
    * mutual TLS (use of a client certificate)
    * OAuth2's common flows (implicit, password, client credentials and authorization code) as defined in RFC6749, and [[OpenID-Connect-Core]].
    
    Please note that as of 2020, the implicit flow is about to be deprecated by OAuth 2.0 Security Best Current Practice. Recommended for most use cases is Authorization Code Grant flow with PKCE.
    """

    def __init__(self, d:dict[str,Any] = None, type:SecuritySchemeType = None, description:str = None, name:str = None, location:ParameterLocation = None, scheme:str = None, bearerFormat:bool = None, flows:OAuthFlows = None, openIdConnectUrl:str = None) -> None:
        super().__init__(d)
        if d is None:
            self.type = type
            self.description = description
            self.name = name
            self.location = location
            self.scheme = scheme
            self.bearerFormat = bearerFormat
            self.flows = flows
            self.openIdConnectUrl = openIdConnectUrl

    @property
    def type(self) -> SecuritySchemeType:
        """REQUIRED. The type of the security scheme. Valid values are "apiKey", "http", "mutualTLS", "oauth2", "openIdConnect"."""
        v = self.get('type', None)
        return SecuritySchemeType.HTTP if v is None else SecuritySchemeType(v)
    @type.setter
    def type(self, v:SecuritySchemeType) -> None:
        self['type'] = v.value

    @property
    def description(self) -> str|None:
        """
        A description for security scheme. CommonMark syntax MAY be used for rich text representation.
        """
        return self.get('description', None)
    @description.setter
    def description(self, v:str|None) -> None:
        if v is None:
            del self['description']
        else:
            self['description'] = v

    @property
    def name(self) -> str|None:
        """
        REQUIRED (FOR APIKEY). The name of the header, query or cookie parameter to be used.
        """
        return self.get('name', None)
    @name.setter
    def name(self, v:str|None) -> None:
        if v is None:
            del self['name']
        else:
            self['name'] = v

    @property
    def location(self) -> ParameterLocation|None:
        """
        REQUIRED FOR APIKEY. The location of the API key. Valid values are "query", "header", or "cookie".
        """
        v = self.get('in', None)
        return None if v is None else ParameterLocation(v)
    @location.setter
    def location(self, v:ParameterLocation|None) -> None:
        if v is None:
            del self['in']
        elif v == ParameterLocation.PATH:
            raise Exception(f'Value of `{v.value}` cannot be used for SecurityScheme.')
        else:
            self['in'] = v.value

    @property
    def scheme(self) -> str|None:
        """REQUIRED FOR HTTP AUTH. The name of the HTTP Authentication scheme to be used in the Authorization header as defined in RFC7235. The values used SHOULD be registered in the IANA Authentication Scheme registry. The value is case-insensitive, as defined in RFC7235."""
        return self.get('scheme', None)
    @scheme.setter
    def scheme(self, v:str|None) -> None:
        if v is None:
            del self['scheme']
        else:
            self['scheme'] = v

    @property
    def bearerFormat(self) -> str|None:
        """A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes."""
        return self.get('bearerFormat', None)
    @bearerFormat.setter
    def bearerFormat(self, v:str|None) -> None:
        if v is None:
            del self['bearerFormat']
        else:
            self['bearerFormat'] = v

    @property
    def flows(self) -> OAuthFlows|None:
        """REQUIRED FOR OAUTH2. An object containing configuration information for the flow types supported."""
        v = self.get('flows', None)
        return None if v is None else OAuthFlows(v)
    @flows.setter
    def flows(self, v:OAuthFlows|None) -> None:
        if v is None:
            del self['flows']
        else:
            self['flows'] = v.asDictionary()

    @property
    def openIdConnectUrl(self) -> str|None:
        """REQUIRED FOR OPENIDCONNECT. Well-known URL to discover the [[OpenID-Connect-Discovery]] provider metadata."""
        return self.get('openIdConnectUrl', None)
    @openIdConnectUrl.setter
    def openIdConnectUrl(self, v:str|None) -> None:
        if v is None:
            del self['openIdConnectUrl']
        else:
            self['openIdConnectUrl'] = v
